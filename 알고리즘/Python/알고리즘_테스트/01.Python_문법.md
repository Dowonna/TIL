2021-08004 | 신규 작성

---

# 1. Python 문법

## 1.1 인덴트(Indent)

Python을 대표하는 특징이기도 한 인덴트는 PEP 8 공식 가이드에 따라 공백 4칸을 원칙으로 한다.

[PEP 8 -- Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/)

예전에는 인덴트를 공백 2칸을 하거나 탭을 권장했으나 PEP 8 이후(지금은)에는 이 기준을 준수하도록 하자. 공백 4칸 원칙외에도 다음과 같은 기준들도 있다.

- 첫 번째 줄에 파라미터가 있다면 시작되는 부분에 아래와 같이 작성해야 한다.

```python
sweet = sweets_and_candy(caramel, pudding, crepes, tarts)
```

```python
def sweets_and_candy(caramel, pudding, crepes, tarts):
	print('crepes')
```

- 위의 코드에서 여러 줄로 나눠쓰고 싶으면 다음 행과 구분되도록 인덴트를 추가해야 한다.

```python
sweet = sweets_and_candy(
		caramel, pudding,
		crepes, tarts)
```

## 1.2 네이밍 컨벤션(Naming Convention)

Java와는 달리 Python은 각 단어는 물론이고 함수명 또한 언더스코어(underscore, _)로 구분하여 표기하는 스네이크 케이스(Snake Case)를 따른다. 따라서 가급적이면 직접 작성하는 코드는 소문자 변수명과 함수명을 원칙으로 하는 습관을 기르도록 하자.

특히 Python은 Java 스타일로 코딩하거나 카멜 케이스(Camel Case)로 코딩하는 방식을 지향한다(Java에서는 대소문자를 구별하여 표기하는 카멜 케이스 스타일을 원칙으로 함).

- 스네이크 케이스 : 각 단어를 언더스코어(_)로 구분한다. Python은 PEP 8을 통해 스네이크 방식의 네이밍 컨벤션을 권장한다. - **예) `snake_case: int = 1`**
- 카멜 케이스 : 단어를 대소문자로 구분하여 섞어서 작명하는 방식이며. 주로 Java에서 사용되는 표기 방식이다. - **예) `camelCase: int = 1`**

## 1.3 타입 힌트(Type Hint)

Python은 동적 타이핑 언어임에도 타입을 지정할 수 있는 타입 힌트가 PEP 484 문서에 추가되었다. 이 기능은 Python 버전 3.5부터 사용할 수 있다.

[PEP 484 -- Type Hints](https://www.python.org/dev/peps/pep-0484/)

타입 힌트에 대한 예시로 CPython의 typing.py가 있는데, 그 전에 CPython에 대한 설명은 다음과 같다.

> C파이썬(CPython)은 파이썬 프로그래밍 언어의 참조 구현체이다. C와 파이썬으로 작성된 C파이썬은 이 언어에 가장 널리 사용되는 기본 구현체이다.

> C파이썬은 인터프리트 과정 이전에 파이썬 코드를 바이트코드로 컴파일하기 때문에 인터프리터이기도 하고 컴파일러이기도 하다. C를 포함한 여러 언어의 외부 함수 인터페이스를 보유하고 있으며 여기서 파이썬 외의 언어로 바인딩을 명시적으로 작성해야 한다.

위의 인용문는 [위키백과](https://ko.wikipedia.org/wiki/C%ED%8C%8C%EC%9D%B4%EC%8D%AC)에서 발췌한 것이다.

다음으로 typing.py에는 선언할 수 있는 타입이 잘 명시되어 있으며, 다음과 같은 형태로 타입을 출력할 수 있다.

```python
# 타입 힌트를 사용하지 않은 함수 예시
x: int = 1
y: str = "1"
```

예를 들어 기존에 타입 힌트를 사용하지 않는 Python 함수는 다음과 같이 함수를 정의해 사용해왔다.

```python
def fn(x):
		...
```

빠르게 정의해서 사용할 수 있다는 장점이 있지만 fn() 함수의 파라미터 y에는 문자를 넘겨야 하는지, 숫자를 넘겨야 하는지 전혀 알 수 없으며 이 함수의 리턴값이 무엇인지도 알 수 없다. 이는 가독성을 해치기 때문에 다음 코드와 같이 개선해 줄 필요가 있다.

```python
# 타입 힌트를 사용하여 함수를 개선한 예시
def fn(y: int) -> bool:
		...
```

타입 힌트를 사용하게 되면 이제 fn() 함수의 파라미터 y가 정수형임을 분명하게 알 수 있으며 리턴값으로 True 또는 False를 리턴할 것이라는 점도 분명히 알 수 있다. 이러한 방법으로 명시적으로 선언하게 되면 가독성이 좋아지며 버그 발생 확률을 줄일 수 있다.

단, 강제 규약이 아니기 때문에 여전히 동적으로 할당될 가능성이 있으므로 주의가 필요하다. 따라서 다음과 같이 문자열에 정수를 할당하는 등의 사용방식은 지양해야 한다.

```python
>>> y: str = 1
>>> type(y)
<class 'int'>
```

코딩 테스트는 보통 짧은 알고리즘으로 끝나는 경우가 많고, 타입은 지정하지 않아도 명확하기 때문에 굳이 지정하지 않아도 크게 문제되지는 않는다. 그러나 코드를 정리할 때만이라도 타입을 지정해서 제출한다면 좋은 결과를 얻을 수 있을 것으로 기대된다.

프로그래머스와 같은 온라인 코딩 테스트 시에는 mypy를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있으므로 이를 통해 수정 후 코드를 제출할 수 있다. mypy는 다음과 같은 pip 명령어로 설치할 수 있다.

```
$ pip install mypy
```

만약 타입 힌트가 잘못 지정된 코드가 발견되면 다음과 같이 Incompatible return value type 오류가 발생하므로 확인 후 코드를 수정할 수 있다.

```
$mypy test.py
test.py:11: error: Incompatible return value type (got "str", expected "int")
Found 1 error in 1 file (checked 1 source file)
```

## 1.4 리스트 컴프리헨션(List Comprehension)

기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로, Python의 2.0 버전부터 지원되었으며, 함수형 언어 중 하나인 하스켈(Haskell)에서 기능을 차용해온 대표적인 특징이기도 하다.

다음은 홀수인 경우 2를 곱해 출력하라는 리스트 컴프리헨션이다.

```python
>>> [n * 2 for n in range(1, 10 + 1) if n % 2 == 1]
# 출력
[2, 6, 10, 14, 18]
```

만약 리스트 컴프리헨션을 사용하지 않는다면 다음과 같이 길게 풀어서 작성해야 한다.

```python
>>> x = []
>>> for n in range(1, 10 + 1);
...     if n % 2 == 1:
...         a.append(n * 2)
...
>>> x
# 출력
[2, 6, 10, 14, 18]
```

코드가 길어진 것 외에도 x라는 별도의 리스트 변수 또한 필요해졌다. 사용했을 때와 비교해보면 라인의 수가 많아짐을 확인할 수 있다. 그렇다고 리스트 컴프리헨션은 이름 그대로 리스트만 가능한 것은 아니다. Python 버전 2.7 이후에는 다음과 같이 리스트 외에도 딕셔너리 등이 가능하도록 추가되었다.

```python
x = {}
for key, value in sweet.items():
		x[key] = value
```

이와 같은 정의 코드는 다음과 같이 처리할 수 있다.

```python
x = {key: value for key, value in sweet.items()}
```

이처럼 코드를 한 줄로 간결하게 작성할 수 있는 리스트 컴프리헨션은 가독성이 좋은 편이지만 무리하게 그리고 복잡하게 작성할 경우 가독성을 해칠 수 있으므로 적절히 사용하는 것이 중요하다. 보통 표현식은 2개를 넘기지 않는 편이다.

## 1.5 제너레이터(Generator)

Python 버전 2.2부터 추가된 기능으로, 루프의 반복(Iteration) 동작을 제어할 수 있는 루틴 형태를 말한다. 만약 임의의 조건으로 숫자 100만 개를 생성한 후 이를 계산하는 프로그램을 작성해야 한다고 가정해보자. 제너레이터가 없다면 현재 사용 중인 컴퓨터의 메모리 어딘가에 만들어낸 숫자 100만 개를 보관하고 있어야 한다. 하지만 제너레이터를 이용하면, 단순히 제너레이터만 생성해두고 필요할 때 언제든 숫자를 만들어낼 수 있다. 숫자가 100만 개 이상이거나 그 중에서 10개 정도만 쓰인다면 그 차이는 더욱 클 것이다.

이때 yield 구문을 사용하면 제너레이터를 리턴할 수 있다. 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료한다. 하지만 yield는 제너레이터가 여기까지 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 맨 끝에 도달할 때 까지 계속 실행된다. 다음 코드의 경우 while True 구문은 종료 조건이 없으므로 계속해서 값을 내보낼 수 있다.

 

```python
>>> def get_natural_number():
...     n = 0
...     while True:
...        n += 1
...        yield n
...
```

이 경우 함수의 리턴값은 다음과 같이 제너레이터가 된다.

```python
>>> get_natural_number()
# 출력
<generator object get_natural_number at 0x10d3139d0>
```

만약 다음 값을 생성하려면 next()로 추출하면 된다. 예를 들어 1000개의 값을 생성하고 싶다면 다음과 같이 1000번 동안 next()를 수행하면 된다.

```python
>>> g = get_natural_number()
>>> for _ in range(0, 1000):
...     print(next(g))
# 출력
1
2
3
4
...
997
998
999
1000
```

그리고 제너레이터는 다음과 같이 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.

```python
>>> def generator():
...     yield 1
...     yield 'string'
...     yield True
>>> g = generator()
>>> g
# 출력
<generator object at generator at 0x10a47c678>
>>> next(g)
# 출력
1
>>> next(g)
# 출력
'string'
>>> next(g)
# 출력
True
```

## 1.6 range

제너레이터의 방식을 활용하는 대표적인 함수로 range()가 있다. 주로 for 문에서 쓰이며 사용 방법은 다음과 같다.

```python
>>> list(range(5))
# 출력
[0, 1, 2, 3, 4]
>>> range(5)
# 출력
range(0, 5)
>>> type(range(5))
# 출력
<class 'range'>
>>> for i in range(5):
...     print(i, end=' ')
...
# 출력
0 1 2 3 4
```

range()는 range 클래스를 리턴하며, for 문에서 사용할 경우 내부적으로는 제너레이터의 next()를 호출하듯 매번 다음 숫자를 생성해내게 된다.

만약 생성할 숫자가 100만 개쯤 된다면 어떻게 될까? 메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것이다. 하지만 제너레이터를 리턴하듯 range 클래스만 리턴하면 오래 걸리지 않을 것이다. 생성 조건만 정해두고 필요할 때 생성해서 원하는 방식대로 사용할 수 있기 때문이다.

다음은 숫자 100만 개를 생성하는 2가지 방법이다.

```python
>>> x = [n for n in range(1000000)]
>>> y = range(1000000)
```

실제로 다음과 같이 len()으로 길이를 비교해보면 둘 다 동일하게 출력되며, 비교 연산자에서도 True를 리턴한다.

```python
>>> len(x)
# 출력
1000000
>>> len(y)
# 출력
1000000
>>> len(x) == len(y)
# 출력
True
```

하지만 x에는 이미 생성된 값이 담겨 있고, y는 생성해야 한다는 조건만 존재한다.

```python
>>> y
# 출력
range(0, 1000000)
>>> type(y)
# 출력
<class 'range'>
```

x와 y 사이의 메모리 점유율을 비교해보면 range 클래스를 리턴하는 방식의 장점을 확인할 수 있을 것이다.

```python
>>> sys.getsizeof(x)
# 출력
8697464
>>> sys.getsizeof(y)
# 출력
48
```

x, y 모두 숫자 100만 개를 갖고 있으나 range 클래스를 이용하는 y 변수의 메모리 점유율이 훨씬 작다. 생성 조건만 보관하고 있기 때문이다. 게다가 미리 생성하지 않은 값은 인덱스에 접근이 불가능하다고 생각할 수 있으나, 인덱스로 접근 시에는 바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 사용할 수 있다.

```python
>>> y[999]
# 출력
999
```

## 1.7 enumerate

enumerate()는 '열거하다'는 뜻의 함수로, 순서가 잇는 자료형(set, tuple, list 등)을 인덱스를 포함한 enumerate 객체로 리턴한다. 사용 방법은 다음과 같다.

```python
>>> x = [1,2,3,2,77,2,5]
>>> x
# 출력
[1, 2, 3, 2, 77, 2, 5]
>>> enumerate(x)
# 출력
<enumerate object at 0x1010f83f0>
>>> list(enumerate(x))
# 출력
[(0, 1), (1, 2), (2, 3), (3, 2), (4, 77), (5, 2), (6, 5)]
```

이처럼 list()로 결과를 추출할 수 있는데, 인덱스를 자동으로 부여해주기 때문에 편리하게 활용할 수 있다.

그렇다면 `x = ['a1', 'b2', 'c3']`가 있을 때 이 리스트의 인덱스 값과 함께 출력하려면 어떻게 해야 할까?

```python
for i in range(len(x)):
		print(i, x[i])
```

위 코드를 보면 값을 가져오기 위해 불필요한 x[i] 검색 작업과 전체 길이를 검색하여 루프를 처리하는 형태가 그다지 간결해 보이지 않는다. 굳이 range()를 사용하지 않고, 다음과 같이 작성할 수도 있다.

```python
i = 0
for v in x:
		print(i, v)
		i += 1
```

값은 간결하게 처리한 것으로 보이나 이 경우에는 인덱스를 위한 변수를 별도로 관리하는 형태인 관계로 전반적인 코드 형태가 간결하지 않다. 여기서 enumerate()를 활용하게 된다면 보다 간결하게 코드를 작성할 수 있을 것이다.

```python
for i, v in enumerate(x):
		print(i, v)
```

인덱스와 값 모두 깔끔하게 처리되었다.

## 1.8 // 나눗셈 연산자

PEP 238에서 기본 나눗셈 연산자의 동작 방식이 변경되었다. 이 PEP에는 이외에도 타입을 유지하는 연산자로 슬래시가 하나 더 붙는 // 나눗셈 연산자가 추가되었는데, 과거의 / 나눗셈 연산자와 동일한 역할을 한다. 정수형을 나눗셈할 때 동일한 정수형을 결과로 리턴하면서 내림 연산자(Floow Division)의 역할을 한다. 즉 몫(Quotient)를 구하는 연산자로 보면 된다.

```python
>>> 5 / 3
# 출력
1.666...67
>>> type(5 / 3)
# 출력
<class 'float'>

# // 나눗셈 연산자는 int(x / y)와 동일함
>>> 5 // 3
# 출력
1
>>> type(5 // 3)
# 출력
<class 'int'>
>>> int(5 / 3)
# 출력
1
>>> type(int(5 / 3))
# 출력
<class 'int'>
```

`5 // 3`은 `int(5 / 3)`과 동일하며 편리하게 사용할 수 있다. 참고로 나머지(Remainder)를 구하는 모듈로(modulo) 연산자는 %이며 다음과 같이 사용할 수 있다.

```python
# 나머지를 구할 수 있는 모듈로 연산자(%)
>>> 7 % 3
# 출력
1
```

몫과 나머지를 동시에 구하려면 divmod() 함수를 사용하면 된다.

```python
# 몫과 나머지를 한 번에 구할 수 있는 divmod() 함수
>>> divmod(7, 3)
# 출력
(2, 1)
```

## 1.9 print

문제 풀이 과정에서 디버깅을 할 때 가장 자주 쓰는 명령은 바로 `print()` 함수이다. 대부분 코딩 테스트 플랫폼에서는 적어도 print()를 통해 출력 결과를 보여주어 디버깅 용도로 활용할 수 있도록 지원한다. 하지만 정답 제출시에는 print()조차 보여주지 않는 경우가 있으니 유의할 필요가 있다. 그렇다면 이를 좀 더 유용하게 활용할 수 있는 방법을 살펴보도록 하자.

가장 쉽게 값을 출력하는 방법은 콤마(,)로 구분하는 것이다. 이 경우 한 칸 공백이 디폴트로 설정되어 있으며, 그대로 출력하면 띄어쓰기로 값을 구분해준다.

```python
>>> print('Kamil', 'Lee')
# 출력
Kamil Lee
```

다음과 같이 `sep` 파라미터로 구분자를 콤마(,)로 지정해줄 수도 있다.

```python
>>> print('Kamil' 'Lee', sep=',')
# 출력
Kamil,Lee
```

print() 함수는 항상 줄바꿈을 하기 때문에 긴 루프의 값을 반복적으로 출력하면 디버깅하기 어려운데 이러한 경우에는 다음과 같이 `end` 파라미터를 공백으로 처리하여 줄바꿈을 하지 않도록 제한할 수 있다.

```python
>>> print('Lee', end=' ')
>>> print('Minjae')
# 출력
Lee Minjae

리스트 형태로 출력할 때는 `join()` 함수로 묶어서 처리한다.

```python
>>> a1 = ['parousia', '0918']
>>> print(' ', join(a1))
# 출력
parousia 0918
```

다음과 같이 `idx`와 `name`이 정의되어 있다고 가정하면,

```python
>>> idx = 1
>>> name = "Lee Minjae"
```

idx 값에 1을 더해서 name과 함께 출력하는 방법은 어떤 방법이 있을까?

```python
>>> print('{0}: {1}'.format(idx + 1, name))
# 출력
2: Lee Minjae
```

이런 형태로 인덱스와 함께 사용 가능하다. 또한 다음과 같이 인덱스를 생략할 수 있다.

```python
>>> print('{}: {}'.format(idx + 1, name))
# 출력
2: Lee Minjae
```

가장 선호하는 방법은 "f-string(formated string literal)"이다. 변수를 뒤에 별도로 부여할 필요 없이 마치 템플릿을 사용하듯 인라인으로 삽입할 수 있어서 편리하게 사용할 수 있다. 무엇보다 기존의 `%`를 사용하거나 `.format`을 부여하는 방식에 비해 훨씬 간결하고 속도가 빠르다.

```python
>>> print(f'{idx + 1}: {name}')
# 출력
2: Lee Minjae
```

단, 이러한 방법은 파이썬 3.6+에서만 지원한다는 점이다. 이하의 버전에서는 동작하지 않으니 유의하기 바란다.